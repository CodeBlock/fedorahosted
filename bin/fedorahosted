#!/usr/bin/env python
# Fedora Hosted Processor
# Ricky Elrod <codeblock@fedoraproject.org>
# GPLv2+

import argparse
import urllib2
import json
import getpass
import socket
import sys
import os
import subprocess
import shlex
import ConfigParser

parser = argparse.ArgumentParser(description='Fedora Hosted Request CLI')
parser.add_argument('-n',
                    '--noop',
                    action='store_true',
                    help="Don't actually execute any commands.")
parser.add_argument('-v',
                    '--verbose',
                    action='store_true',
                    help="Be verbose, for debugging.")
parser.add_argument('-p',
                    '--process',
                    dest="REQUEST_ID",
                    help='Process a Fedora Hosted request (for admins).')
parser.add_argument('-r',
                    help='Request a new Fedora Hosted project.')
parser.add_argument('-s',
                    '--server',
                    dest="SERVER",
                    help='Server hosting the Fedora Hosted Request web app.')
parser.add_argument('-i',
                    '--private-key',
                    dest="PRIVATE_KEY",
                    help='The private SSH key we should authenticate to' \
                        'mailing list servers with.')
parser.add_argument('-c',
                    '--config',
                    dest="CONFIG",
                    default="/etc/fedorahosted/cli.conf",
                    help='A configuration file to use.')
args = parser.parse_args()

# Handle the config file here, if it exists.
config = None
if os.path.exists(args.CONFIG):
    config = ConfigParser.ConfigParser()
    config.read(args.CONFIG)

def get_option_value(argname, section, key, die=True, default=None, warning=None):
    if argname in args.__dict__.keys() and args.__dict__[argname] != None:
        return args.__dict__[argname]
    elif config:
        return config.get(section, key)
    elif default:
        if warning:
            print '[warning] ' + warning
        else:
            print '[warning] No argument %s passed or config file setting ' \
                '%s.%s. Defaulting to %s.' % (argname, section, key, default)
        return default
    elif die:
        print "[error] Missing required argument %s (or config setting: %s.%s)" \
            % (argname, section, key)
        sys.exit(1)
    else:
        return None

server = get_option_value('SERVER', 'fedorahosted_cli', 'server',
                          default='http://localhost:5000')

private_key = get_option_value('PRIVATE_KEY', 'fedorahosted_cli',
                               'private_key')

def run_command_if_allowed(command):
    """
    Runs a system command and prints the result.
    "allowed" is determined by the state of args.noop.
    """
    print "[root@%s %s]# %s" % (
        socket.gethostname(),
        os.getcwd(),
        command)
    if args.noop:
        return
    escaped = shlex.split(command)
    cmd = subprocess.Popen(escaped,
                           stdout=subprocess.PIPE,
                           stderr=subprocess.PIPE)
    stdout, stderr = cmd.communicate()
    if stdout:
        print "[stdout] %s" % stdout.strip()
    if stderr:
        print "[stderr] %s" % stderr.strip()


def verbose_print(text):
    """Prints a line if we are in verbose mode."""
    if args.verbose:
        print text

if args.noop:
    print
    print "*** Running in NO-OP mode, not executing any commands. ***"
    print "*** Not asking for FAS info, no FAS communication will happen. ***"
    print "If everything looks good below, run without -n/--noop"
    print

if args.REQUEST_ID:
    if not args.noop:
        user = getpass.getuser()
        if user != "root":
            print "Processing requests should be run as root."
            print "However, you can run with --noop as an unprivileged user."
            sys.exit(1)
        processor_username = raw_input("FAS username: ")
        processor_password = getpass.getpass("FAS password: ")

    request = urllib2.urlopen(args.SERVER + '/getrequest?id=' +
                              args.REQUEST_ID,
                              timeout=5)  # Give up after 5 seconds.
    project = json.loads(request.read())

    verbose_print("Response from the webapp server: %s" % project)

    if 'error' in project:
        print "ERROR: %s" % project['error']
        sys.exit(1)

    project_group = str(project['scm'] + project['name'])

    # print "Creating FAS group: " + project_group
    # if not create_fas_group(project_group):
    #     print "ERROR creating FAS group: " + project['scm'] + project['name']
    #     sys.exit(1)

    # I wish Python had a switch/case equivalent.
    if project['scm'] == 'git':
        print "Creating /git/" + project['name'] + ".git directory."
        print "Entering /git/" + project['name'] + ".git directory."
        if not args.noop:
            os.mkdir("/git/" + project['name'] + ".git")
            os.chdir("/git/" + project['name'] + ".git")
            print "Working directory: " + os.getcwd()

        run_command_if_allowed("git --bare init --shared=true")

        print "Writing 'description' file."
        if not args.noop:
            with open("description", "w") as description:
                description.write(project['description'])

        print "Creating post-update symlink."
        if not args.noop:
            if os.path.isfile("hooks/post-update"):
                os.unlink("hooks/post-update")
            os.symlink(
                "/usr/share/git-core/templates/hooks/post-update.sample",
                "hooks/post-update")

        # TODO: Is it worth pythonizing these one day?
        run_command_if_allowed("git update-server-info")
        run_command_if_allowed("find -type d -exec chmod g+s {} ;")
        run_command_if_allowed(
            "find -perm /u+w -a ! -perm /g+w -exec chmod g+w {} ;")
        run_command_if_allowed(
            "chown -R " + str(project['owner']) + ":" + project_group + " .")

        # TODO: Mailing (and commit) lists.

    elif project['scm'] == 'hg':
        do_things()
    elif project['scm'] == 'svn':
        do_things()
